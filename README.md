# SpringBoot-RabbitMQ
本案例为springboot整合rabbitmq的五种工作模式。

springboot不需要在启动类前加@EnableRabbit和新建ConnectionFactory(),因为可以在yml里配置rabbitmq的选项。

本案例开启的消息确认机制,持久化了交换机,队列以及消息,消费者端开启了手动ACK,保证非极端情况下消息的可靠性。

配置简单,doem中有详细的注释,通俗易懂

五种工作模式

官网介绍：https://www.rabbitmq.com/getstarted.html

这里简单介绍下五种工作模式的主要特点：

简单模式：一个生产者，一个消费者

work模式：一个生产者，多个消费者，每个消费者获取到的消息唯一。

订阅模式：一个生产者发送的消息会被多个消费者获取。

路由模式：发送消息到交换机并且要指定路由key ，消费者将队列绑定到交换机时需要指定路由key

topic模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词。

# 新增RabbitMQ死信队列

RabbitMQ要实现延时任务，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）来实现

死信交换机

死信交换机跟普通交换机一样,只是这个交换机用来存放过期的消息

当一个消息没有相对应的消费者对其进行消费, 并且消息设置了TTL,消息过期后会进入死信交换机。

队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。

当消息进入死信交换机后,死信交换机在把消息转发给专门处理死信消息的消费者,及可实现定时任务

设置消息TTL（消息存活时间）

消息的TTL就是消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL。对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。

超过了这个时间，我们认为这个消息就死了，称之为死信。如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置
# SpringBoot-RabbitMQ-Demo
